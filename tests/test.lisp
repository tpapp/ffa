(require :ffa)

(defpackage #:ffa-test
  (:use :common-lisp :bind :iterate :ffa :cffi)
  (:shadowing-import-from :iterate :collecting :collect))

(in-package #:ffa-test)

(load "lisp-unit.lisp")
(use-package :lisp-unit)

;;;; interface to foreign code

;;;; Testing :copy-in - functions below return the sum of elements in
;;;; a vector (or something that is a bit different in the complex
;;;; case).

(load-foreign-library "./libtest.so")

(defcfun (sum-uchar "sum_uchar") :uint16
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-ushort "sum_ushort") :uint16
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-ulong "sum_ulong") :uint32
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-float "sum_float") :float
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-double "sum_double") :double
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-uchar "sum_uchar") :uint16
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-ushort "sum_ushort") :uint16
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-ulong "sum_ulong") :uint32
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-float "sum_float") :float
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-double "sum_double") :double
  (length :uint16)
  (sequence :pointer))

;;; important: complex number test functions return (abs(sum))^2

(defun complex-abs-square (c)
  (flet ((square (x)
	   (expt x 2)))
    (+ (square (realpart c)) (square (imagpart c)))))

(defcfun (sum-complex-float "sum_complex_float") :float
  (length :uint16)
  (sequence :pointer))

(defcfun (sum-complex-double "sum_complex_double") :double
  (length :uint16)
  (sequence :pointer))

;;;; Testing :copy-in-out by adding 1 (or 1+1i for the complex case)
;;;; to a vector.

(defcfun (add1-uchar "add1_uchar") :void
  (length :uint16)
  (sequence :pointer))

(defcfun (add1-ushort "add1_ushort") :void
  (length :uint16)
  (sequence :pointer))

(defcfun (add1-ulong "add1_ulong") :void
  (length :uint16)
  (sequence :pointer))

(defcfun (add1-float "add1_float") :void
  (length :uint16)
  (sequence :pointer))

(defcfun (add1-double "add1_double") :void
  (length :uint16)
  (sequence :pointer))

;;; important: complex number add #C(1.0 1.0) instead of 1.0

(defcfun (add1-complex-float "add1_complex_float") :void
  (length :uint16)
  (sequence :pointer))

(defcfun (add1-complex-double "add1_complex_double") :void
  (length :uint16)
  (sequence :pointer))

;;;; functions used by tests

(defun number-sequence (start step length elt-type)
  "Return a vector of `length' numbers, element-type `elt-type',
starting at `start' and increasing by `step'.  Note: you should use
integers (but not necessarily integer types!, eg 2d0) to avoid
numerical errors."
  (let ((v (make-array length :element-type elt-type)))
    (iter 
     (for i :from 0 :below length)
     (for x :from start :by step)
     (setf (aref v i) x))
    v))

(defun sum-sequence (start step length)
  "Return the sum (calculated algebraically, not numerically) of a
sequence that would be generated by number-sequence."
  (+ (* length start)
     (/ (* step length (1- length)) 2)))

(defun test-copy-in (start step length cffi-type foreign-sum-function
		     &optional complex-p)
  (let* ((sequence (number-sequence start step length (elt-type cffi-type)))
	 (sum1 (sum-sequence start step length))
	 (sum2 (with-pointer-to-array (sequence pointer cffi-type length :copy-in)
		 (funcall foreign-sum-function length pointer))))
    (= (if complex-p
	   (complex-abs-square sum1)
	   sum1)
       sum2)))

(defun test-copy-in-out (start step length cffi-type foreign-add1-function
			 &optional complex-p)
  (let* ((elt-type (elt-type cffi-type))
	 (sequence (number-sequence start step length elt-type))
	 (sequence2 (map (list 'vector elt-type) (if complex-p
						    (lambda (x)
						      (+ x #C(1 1)))
						    #'1+) sequence)))
    (with-pointer-to-array (sequence pointer cffi-type length :copy-in-out)
      (funcall foreign-add1-function length pointer))
    (equalp sequence sequence2)))

;;; actual tests

(define-test copy-in
  (assert-true (test-copy-in 1 2 10 :uint8 #'sum-uchar))
  (assert-true (test-copy-in 1 2 10 :uint16 #'sum-ushort))
  (assert-true (test-copy-in 1 2 10 :uint32 #'sum-ulong))
  (assert-true (test-copy-in 1s0 2s0 10 :float #'sum-float))
  (assert-true (test-copy-in 1d0 2d0 10 :double #'sum-double))
  (assert-true (test-copy-in #C(1s0 2s0) 3s0 10 :complex-float
			     #'sum-complex-float t))
  (assert-true (test-copy-in #C(1d0 2d0) 3d0 10 :complex-double
			     #'sum-complex-double t)))

(define-test copy-in-out
  (assert-true (test-copy-in-out 1 2 10 :uint8 #'add1-uchar))
  (assert-true (test-copy-in-out 1 2 10 :uint16 #'add1-ushort))
  (assert-true (test-copy-in-out 1 2 10 :uint32 #'add1-ulong))
  (assert-true (test-copy-in-out 1s0 2s0 10 :float #'add1-float))
  (assert-true (test-copy-in-out 1d0 2d0 10 :double #'add1-double))
  (assert-true (test-copy-in-out #C(1s0 2s0) 3s0 10 :complex-float
				 #'add1-complex-float t))
  (assert-true (test-copy-in-out #C(1d0 2d0) 3d0 10 :complex-double
				 #'add1-complex-double t)))


(run-tests copy-in)
(run-tests copy-in-out)

